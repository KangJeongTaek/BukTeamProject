---

### 2024-05-27

1. 프로젝트를 생성하고 IDE를 이클립스로 결정했으나, 깃허브 데스크탑으로 Push후 Repository를 Clone해오면 해당 프로젝트를 자바 프로젝트 파일로 인식을 못 하는 상황이 발생.
아마, 이클립스에서 자바 프로젝트로 인식하기 위한 파일을 .gitignore 설정을 해주지 않아서 발생한 오류로 생각되어짐. 허나, 설정을 고치지는 아니하고 향후의 오류도 고려해 IDE를 VS Code로 바꾸기로 결정.
2. VS Code에서도 비슷한 오류가 발생. 환경 변수에서 JAVA_HOME의 디렉토리와 bin 폴더를 등록. VS Code의 setting.json 파일에서도 JDK 경로를 설정 후 해결.

### 2024-05-28

1. JPA관련 예외가 자꾸 발생. → @OnDelete어노테이션 속성으로 action = OndeleteAction.RESTRICT를 주고 있었는데 오라클에서는 RESTRICT 옵션이 없고 CASADE를 사용하기에 발생하는 예외였음. 수정 후 작동이 되는 걸 확인.
2. JPArepository를 상속받는 인터페이스가 Service 폴더에 들어가 있어야 한다고 생각했으나, Service의 로직은 새로 만들어 따로 관리하는 게 맞다는 주장에 수긍함. 다만, 현재의 상태에서도 필요한 로직은 실행가능하기에 약간의 시간을 두고 수정할 예정.
3. form submit으로 보냈으나 값을 받지 못 하고 null이 들어오는 문제를 발견. → name이 아닌 id 속성을 사용하고 있음을 발견. 수정 후 해결.
4. 값이 들어올 때에 예외가 발생하는 것을 확인. <input type=”date”> 로 넘어온 value 역시 String인 것을 확인하고 DateTimeFormatter클래스와 LocalDate를  활용해 LocalDate로 캐스팅 후 DB에 값을 저장. 
5. 이미지 업로드 구현 완료 - 힘들었던 점 → 설정해주어야 할 게 많다. 
(1) html의 form태그에서 enctype="multipart/form-data” 작성해주기 
(2) 스프링부트 설정에서
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB
추가해주기
(3) 해당 로직 구현하기 MultiPartFile 객체와 Path에 대해서는 더욱 공부할 필요가 있어보임.
6. 향후의 통합을 위해 패키지를 통일하고 각자의 모듈을 새로운 클래스로 구현해야할 필요성을 느낌

### 2024-05-29

1. 팀원 중 한 명이 main 브랜치로 중간 코드를 commit을 하는 일이 발생. 바뀌거나 새로 생긴 코드를 찾아내어 모두 수정 후 초기 상태로 돌려놓은 상태로 다시 commit. 메인 브랜치에 commit 하지 못하도록 조치가 필요함을 느낌
2. PageRequest 객체와 Page 객체를 이용하여 페이지네이션을 구현.
3. 프로젝트 생성 페이지에서 금액란에 숫자를 넣지 못 하도록 처리 완료(HTML type을 number로 수정 후 증감 화살표가 보이지 않도록 css처리)
4. 데이터베이스에서 값을 읽어오고 <c:forEach> 문법을 사용하여 각각의 카드에 정보를 넣어주기 성공
5. 프로젝트 테이블에 새로운 컬럼(후원 금액)이 필요하다고 느껴 데이터베이스 스키마 삭제 후 생성(예정) 
6. ***VS CODE의 확장 중 하나인 gradle for java가 Spring과 관련한 확장과 충돌이 나는 것으로 추정. gradle for java 삭제 후 문제없이 실행되는 것을 확인***

### 2024-05-30

1. 상세 정보 중 글자수가 100자가 넘어가면 잘라내서 표현하는 기능을 수행하기 위해 저장된 객체의 변수에 접근해 수정하고 다시 저장하는 방식을 사용. → 데이터베이스의 정보와 현재 객체의 정보가 달라지는 일이기에 행여 문제가 생기지 않을까 했으나, 그 페이지에서만 사용하고 저장할 일이 전혀 없기에 괜찮다고 판단.
2. 컬럼(후원 금액)을 추가해 충돌이 생기지 않는 것을 확인.
3. @Test 애노테이션과 JPA 관련 설정에서 예외가 발생하는 것을 발견. 오라클에 관련한 임베디드 데이터베이스가 없어서 생긴 예외 였음. 따라서 @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)를 사용하여 실제 데이터베이스 설정을 사용하도록 설정했음.
4. ***@Autowired ←를 생성자에 주는 방식을 사용하고 있었으나 @RequiredArgsConstructor 방식도 있다는 걸 알게 됐음.***
5. 카데고리별 조회와 페이지 이동을 동시에 구현 → 페이지 이동시에 현재 파라미터의 정보를 category=${param.category}식으로 전달했음. → 값이 없으면 빈 값 즉, null이 들어갈 것이라 생각했으나 빈 문자열이 들어가 제대로 동작하지 않는 것을 확인. → 빈 문자열이 들어오면 null로 처리하도록 로직을 구현후 해결.
6. ***찜 목록 테이블 생성. (복합키를 가진 테이블) 복합키의 요소를 변수로 가지고 Serializable를 구현하는 클래스를 생성. → 또한, Project 테이블 그리고, User테이블과 조인할 것이기에 변수를 Project 클래스 타입과 User 클래스 타입으로 생성. 그래서 실제 테이블을 매핑할 클래스에서는 Serializable을 구현한 클래스 타입을 변수로 주고 @EmbeddedId를 주었음. 실행하고 Dbeaver로 확인해보니 관계 설정이 잘 된 것을 확인했음.***
7. 프로젝트 생성 페이지에서 후원 금액 입력칸을 추가하고 이를 목표 금액과 비교하여 후원 금액이 목표 금액보다 크면 입력되지 않도록 설정하고자 js에서 if(form.cost.value < form.targetCost.value)를 사용했으나 둘 모두 타입이 문자열이였기에 잘못된 결과가 나오는 것을 확인. if(parseInt(form.cost.value) < parseInt(form.targetCost.value))로 조건문을 바꾸어 해결.

### 2024-05-31

1. 찜 버튼 구현 완료 → 자바 스크립트에서 Fetch API를 사용하여 컨트롤러에 Json형태로 요청을 보내고 @ResponseBody로 또 다시 Json 형태로 응답을 받게 만들었음.(찜해제 , 찜하기가 새로고침 없이 가능해짐)
2. 기능 구현 중 Json의 밸류값으로 객체를 보냈으나, 작동하지 않는 것을 확인. String값을 보내고 컨트롤러와 서비스 레이어에서 받은 String값으로 해당 고유키를 가지는 엔터티를 찾는 로직을 추가.
3. 찜 테이블이 외래키 2개를 복합키로 가지는 테이블이였기에 매핑에 이해하기에 상당한 노력이 필요했음.(외래키 2개의 객체를 찾고, 그 2개의 객체를 Serializable를 구현한 클래스에 저장한 다음, 그 클래스를 FindById의 매개변수로 넣어주어야 동작이 됐음)
4. Merge 시에 Conflict가 발생. git checkout 명령을 사용한 후 Vscode를 통해 충돌을 제거 후 병합을 시켜주는 것으로 해결

### 2024-06-03

1. 순환 참조 문제, 순환 참조 하고 있는 IndexController와 ProjectService, ProjectSupprotService,ProjectEntity를 나누어 해결했다.
2. 현재 JSP에서 <c:choose>를 많이 사용하고 있는데 별로 좋은 건 아닌 거 같다. javascript단에서 확인하는 게 좋지 않을까 하는 생각이 든다. 하지만, 현재 내가 알고 있는 방식으로는 이게 최선인 듯 하다.
3. view를 신경쓰기 시작했다. 부트스트랩을 공비하기 시작했는데 생각보다 재미있어서 다행이다.
4. **DTO 사용의 필요성을 느낌. Join문의 최소화, 영속성 문제 등등… 다만 현재의 프로젝트는 혼자 하는 것도 아닐뿐더러 많은 양의 데이터를 다루지 않기에 변경하지 않아도 크게 문제가 없을거라 여겨짐.**
5. 또 다시 Fetch API를 사용해 프로젝트 코멘트를 저장하는 로직을 구현했음. 이제 뷰만 꾸미면 끝날 듯함.

### 2024-06-04

1. 프로젝트 코멘트와 관련한 RestAPI를 구현해보려고 노력해보았음.  조회, 생성, 삭제까지 이루어냈으나, 수정은 필요가 없을거라 생각되어 구현하지 않음. @DeleteMapping / @PostMapping을 사용해보았음. (간단하고 일관성이 있어서 상황만 된다면 이 방식으로 계속 구현하고 싶음)
2. JPQL 사용법을 어느 정도 익혔음. 솔직히 아직 객체 지향의 쿼리문을 완전히 이해했다고 보기는 어려우나, 일반 쿼리문과의 차이는 확실하게 인지했음.
3. 팀원 중 한 명이 잘못된 레포지토리를 Merge하는 바람에 main 브런치 필요한 파일 몇 개가 삭제되고 내부 코드가 바뀌는 일이 발생. 현재 하던 작업을 멈추고, 곧바로 가장 가까운 시일에 생성된 브랜치에서 어떤 파일이 삭제되고, 수정됐는지 확인해서 삭제된 파일은 복구하고 수정된 곳은 비교 검증하는 과정을 거쳐 원상복구 했음.
4. Mybatis를 잠시 공부해보았음. 동적인 쿼리 생성이라는 부분이 상당히 흥미로웠음. 허나, JPA를 먼저 접했기에 지금은 JPA를 사용하는 것이 편리히다고 여겨짐.
5. 필요한 최소한의 기능은 구현했다고 생각됨. 정리가 필요한 시점임.
6. 깃허브 데스크탑의 기능 중 Update from main과 Compare to Branch를 활용할 수 있게 됐음.




### 완성 후 성과
1. 객체 지향 쿼리 (JPA 기술에 대해 어느 정도 이해하게 됐다.)

2. RESTful API 형식으로 로직을 짤 수 있다.

3. Fetch API를 사용하여 컨트롤러와 뷰 사이에서 값을 주고 받을 수 있다.

4. MVC패턴을 이해할 수 있다.

5. 스프링부트로 프로젝트를 생성하고 초기 설정을 할 수 있다.

6. 형상 관리 툴(git)을 통한 협업을 할 수 있다.(할 수만 있지 완벽하지는 않음)
